{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n * parallax.js v1.5.0 (http://pixelcog.github.io/parallax.js/)\n * @copyright 2016 PixelCog, Inc.\n * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)\n */\n!function (t, i, e, s) {\n  function o(i, e) {\n    var h = this;\n    \"object\" == _typeof(e) && (delete e.refresh, delete e.render, t.extend(this, e)), this.$element = t(i), !this.imageSrc && this.$element.is(\"img\") && (this.imageSrc = this.$element.attr(\"src\"));\n    var r = (this.position + \"\").toLowerCase().match(/\\S+/g) || [];\n    if (r.length < 1 && r.push(\"center\"), 1 == r.length && r.push(r[0]), \"top\" != r[0] && \"bottom\" != r[0] && \"left\" != r[1] && \"right\" != r[1] || (r = [r[1], r[0]]), this.positionX !== s && (r[0] = this.positionX.toLowerCase()), this.positionY !== s && (r[1] = this.positionY.toLowerCase()), h.positionX = r[0], h.positionY = r[1], \"left\" != this.positionX && \"right\" != this.positionX && (isNaN(parseInt(this.positionX)) ? this.positionX = \"center\" : this.positionX = parseInt(this.positionX)), \"top\" != this.positionY && \"bottom\" != this.positionY && (isNaN(parseInt(this.positionY)) ? this.positionY = \"center\" : this.positionY = parseInt(this.positionY)), this.position = this.positionX + (isNaN(this.positionX) ? \"\" : \"px\") + \" \" + this.positionY + (isNaN(this.positionY) ? \"\" : \"px\"), navigator.userAgent.match(/(iPod|iPhone|iPad)/)) return this.imageSrc && this.iosFix && !this.$element.is(\"img\") && this.$element.css({\n      backgroundImage: 'url(\"' + this.imageSrc + '\")',\n      backgroundSize: \"cover\",\n      backgroundPosition: this.position\n    }), this;\n    if (navigator.userAgent.match(/(Android)/)) return this.imageSrc && this.androidFix && !this.$element.is(\"img\") && this.$element.css({\n      backgroundImage: 'url(\"' + this.imageSrc + '\")',\n      backgroundSize: \"cover\",\n      backgroundPosition: this.position\n    }), this;\n    this.$mirror = t(\"<div />\").prependTo(this.mirrorContainer);\n    var a = this.$element.find(\">.parallax-slider\"),\n        n = !1;\n    0 == a.length ? this.$slider = t(\"<img />\").prependTo(this.$mirror) : (this.$slider = a.prependTo(this.$mirror), n = !0), this.$mirror.addClass(\"parallax-mirror\").css({\n      visibility: \"hidden\",\n      zIndex: this.zIndex,\n      position: \"fixed\",\n      top: 0,\n      left: 0,\n      overflow: \"hidden\"\n    }), this.$slider.addClass(\"parallax-slider\").one(\"load\", function () {\n      h.naturalHeight && h.naturalWidth || (h.naturalHeight = this.naturalHeight || this.height || 1, h.naturalWidth = this.naturalWidth || this.width || 1), h.aspectRatio = h.naturalWidth / h.naturalHeight, o.isSetup || o.setup(), o.sliders.push(h), o.isFresh = !1, o.requestRender();\n    }), n || (this.$slider[0].src = this.imageSrc), (this.naturalHeight && this.naturalWidth || this.$slider[0].complete || a.length > 0) && this.$slider.trigger(\"load\");\n  }\n\n  !function () {\n    for (var t = 0, e = [\"ms\", \"moz\", \"webkit\", \"o\"], s = 0; s < e.length && !i.requestAnimationFrame; ++s) {\n      i.requestAnimationFrame = i[e[s] + \"RequestAnimationFrame\"], i.cancelAnimationFrame = i[e[s] + \"CancelAnimationFrame\"] || i[e[s] + \"CancelRequestAnimationFrame\"];\n    }\n\n    i.requestAnimationFrame || (i.requestAnimationFrame = function (e) {\n      var s = new Date().getTime(),\n          o = Math.max(0, 16 - (s - t)),\n          h = i.setTimeout(function () {\n        e(s + o);\n      }, o);\n      return t = s + o, h;\n    }), i.cancelAnimationFrame || (i.cancelAnimationFrame = function (t) {\n      clearTimeout(t);\n    });\n  }(), t.extend(o.prototype, {\n    speed: .2,\n    bleed: 0,\n    zIndex: -100,\n    iosFix: !0,\n    androidFix: !0,\n    position: \"center\",\n    overScrollFix: !1,\n    mirrorContainer: \"body\",\n    refresh: function refresh() {\n      this.boxWidth = this.$element.outerWidth(), this.boxHeight = this.$element.outerHeight() + 2 * this.bleed, this.boxOffsetTop = this.$element.offset().top - this.bleed, this.boxOffsetLeft = this.$element.offset().left, this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;\n      var t,\n          i = o.winHeight,\n          e = o.docHeight,\n          s = Math.min(this.boxOffsetTop, e - i),\n          h = Math.max(this.boxOffsetTop + this.boxHeight - i, 0),\n          r = this.boxHeight + (s - h) * (1 - this.speed) | 0,\n          a = (this.boxOffsetTop - s) * (1 - this.speed) | 0;\n      r * this.aspectRatio >= this.boxWidth ? (this.imageWidth = r * this.aspectRatio | 0, this.imageHeight = r, this.offsetBaseTop = a, t = this.imageWidth - this.boxWidth, \"left\" == this.positionX ? this.offsetLeft = 0 : \"right\" == this.positionX ? this.offsetLeft = -t : isNaN(this.positionX) ? this.offsetLeft = -t / 2 | 0 : this.offsetLeft = Math.max(this.positionX, -t)) : (this.imageWidth = this.boxWidth, this.imageHeight = this.boxWidth / this.aspectRatio | 0, this.offsetLeft = 0, t = this.imageHeight - r, \"top\" == this.positionY ? this.offsetBaseTop = a : \"bottom\" == this.positionY ? this.offsetBaseTop = a - t : isNaN(this.positionY) ? this.offsetBaseTop = a - t / 2 | 0 : this.offsetBaseTop = a + Math.max(this.positionY, -t));\n    },\n    render: function render() {\n      var t = o.scrollTop,\n          i = o.scrollLeft,\n          e = this.overScrollFix ? o.overScroll : 0,\n          s = t + o.winHeight;\n      this.boxOffsetBottom > t && this.boxOffsetTop <= s ? (this.visibility = \"visible\", this.mirrorTop = this.boxOffsetTop - t, this.mirrorLeft = this.boxOffsetLeft - i, this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed)) : this.visibility = \"hidden\", this.$mirror.css({\n        transform: \"translate3d(\" + this.mirrorLeft + \"px, \" + (this.mirrorTop - e) + \"px, 0px)\",\n        visibility: this.visibility,\n        height: this.boxHeight,\n        width: this.boxWidth\n      }), this.$slider.css({\n        transform: \"translate3d(\" + this.offsetLeft + \"px, \" + this.offsetTop + \"px, 0px)\",\n        position: \"absolute\",\n        height: this.imageHeight,\n        width: this.imageWidth,\n        maxWidth: \"none\"\n      });\n    }\n  }), t.extend(o, {\n    scrollTop: 0,\n    scrollLeft: 0,\n    winHeight: 0,\n    winWidth: 0,\n    docHeight: 1 << 30,\n    docWidth: 1 << 30,\n    sliders: [],\n    isReady: !1,\n    isFresh: !1,\n    isBusy: !1,\n    setup: function setup() {\n      function s() {\n        if (p == i.pageYOffset) return i.requestAnimationFrame(s), !1;\n        p = i.pageYOffset, h.render(), i.requestAnimationFrame(s);\n      }\n\n      if (!this.isReady) {\n        var h = this,\n            r = t(e),\n            a = t(i),\n            n = function n() {\n          o.winHeight = a.height(), o.winWidth = a.width(), o.docHeight = r.height(), o.docWidth = r.width();\n        },\n            l = function l() {\n          var t = a.scrollTop(),\n              i = o.docHeight - o.winHeight,\n              e = o.docWidth - o.winWidth;\n          o.scrollTop = Math.max(0, Math.min(i, t)), o.scrollLeft = Math.max(0, Math.min(e, a.scrollLeft())), o.overScroll = Math.max(t - i, Math.min(t, 0));\n        };\n\n        a.on(\"resize.px.parallax load.px.parallax\", function () {\n          n(), h.refresh(), o.isFresh = !1, o.requestRender();\n        }).on(\"scroll.px.parallax load.px.parallax\", function () {\n          l(), o.requestRender();\n        }), n(), l(), this.isReady = !0;\n        var p = -1;\n        s();\n      }\n    },\n    configure: function configure(i) {\n      \"object\" == _typeof(i) && (delete i.refresh, delete i.render, t.extend(this.prototype, i));\n    },\n    refresh: function refresh() {\n      t.each(this.sliders, function () {\n        this.refresh();\n      }), this.isFresh = !0;\n    },\n    render: function render() {\n      this.isFresh || this.refresh(), t.each(this.sliders, function () {\n        this.render();\n      });\n    },\n    requestRender: function requestRender() {\n      var t = this;\n      t.render(), t.isBusy = !1;\n    },\n    destroy: function destroy(e) {\n      var s,\n          h = t(e).data(\"px.parallax\");\n\n      for (h.$mirror.remove(), s = 0; s < this.sliders.length; s += 1) {\n        this.sliders[s] == h && this.sliders.splice(s, 1);\n      }\n\n      t(e).data(\"px.parallax\", !1), 0 === this.sliders.length && (t(i).off(\"scroll.px.parallax resize.px.parallax load.px.parallax\"), this.isReady = !1, o.isSetup = !1);\n    }\n  });\n  var h = t.fn.parallax;\n  t.fn.parallax = function (s) {\n    return this.each(function () {\n      var h = t(this),\n          r = \"object\" == _typeof(s) && s;\n      this == i || this == e || h.is(\"body\") ? o.configure(r) : h.data(\"px.parallax\") ? \"object\" == _typeof(s) && t.extend(h.data(\"px.parallax\"), r) : (r = t.extend({}, h.data(), r), h.data(\"px.parallax\", new o(this, r))), \"string\" == typeof s && (\"destroy\" == s ? o.destroy(this) : o[s]());\n    });\n  }, t.fn.parallax.Constructor = o, t.fn.parallax.noConflict = function () {\n    return t.fn.parallax = h, this;\n  }, t(function () {\n    t('[data-parallax=\"scroll\"]').parallax();\n  });\n}(jQuery, window, document);","map":null,"metadata":{},"sourceType":"module"}